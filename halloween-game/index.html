<!doctype html>
<html lang="zh-CN">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>ä¸‡åœ£èŠ‚è¿è¿çœ‹ ğŸƒ</title>
<style>
  :root{
    --bg:#0b0b1a;--bg2:#14142b;--orange:#ffa43a;--purple:#7e5cef;--green:#34d399;--red:#ff6b6b;--text:#f7f7fb;
    --tile:#1d1d36;--tile-hover:#262648;--tile-selected:#34346a;--grid-gap:8px;--radius:14px;--shadow:0 8px 20px rgba(0,0,0,.35)
  }
  html,body{height:100%;background:radial-gradient(1200px 700px at 70% -200px,#1a1440 0%,#0d0b1d 40%,#070711 100%), var(--bg); color:var(--text);font-family: ui-sans-serif,system-ui,Segoe UI,Roboto,Apple Color Emoji,Noto Color Emoji,EmojiSymbols;}
  *{box-sizing:border-box}
  .container{max-width:980px;margin:0 auto;padding:16px}
  header{display:flex;align-items:center;justify-content:space-between;gap:12px;margin:10px 0 16px}
  .title{display:flex;align-items:center;gap:10px;font-weight:800;font-size:clamp(20px,3.2vw,28px)}
  .title .moon{filter:drop-shadow(0 0 10px rgba(255,215,128,.4))}
  .panel{background:linear-gradient(180deg,#151532,#0f0f23);border:1px solid #25254a;border-radius:18px;box-shadow:var(--shadow);padding:14px 16px;display:flex;align-items:center;gap:10px;flex-wrap:wrap}
  .badge{padding:8px 12px;border-radius:999px;background:#1e1e3c;border:1px solid #2e2e5e;font-weight:700}
  .btn{appearance:none;border:0;background:linear-gradient(180deg,#ffb454,#ff9640);color:#3b1800;padding:10px 14px;border-radius:12px;font-weight:800;cursor:pointer;box-shadow:inset 0 -2px 0 rgba(0,0,0,.15),0 6px 14px rgba(0,0,0,.25);transition:.15s transform,.15s filter}
  .btn:active{transform:translateY(1px)}
  .btn.secondary{background:linear-gradient(180deg,#8a82ff,#6c63ff);color:#0a0720}
  .btn.ghost{background:#1f1f3f;color:#c5c6ff;border:1px solid #2f2f63}
  .grid-wrap{margin:18px 0;display:flex;justify-content:center}
  .grid{display:grid;gap:var(--grid-gap);background:#0e0e22;padding:var(--grid-gap);border-radius:18px;border:1px solid #24244a;box-shadow:var(--shadow)}
  .tile{width:64px;height:64px;display:flex;align-items:center;justify-content:center;font-size:34px;line-height:1;background:var(--tile);border-radius:var(--radius);border:1px solid #2b2b55;cursor:pointer;user-select:none;transition:.12s transform,.12s background,.12s box-shadow}
  .tile:hover{background:var(--tile-hover)}
  .tile.selected{background:var(--tile-selected);box-shadow:0 0 0 2px #7e5cef inset}
  .tile.clearing{animation:pop .35s both}
  @keyframes pop{0%{transform:scale(1)}30%{transform:scale(1.15)}100%{transform:scale(.1);opacity:0}}
  .tile.empty{visibility:hidden}
  footer{opacity:.8;text-align:center;margin:16px 0}
  .bar{display:flex;gap:8px;flex-wrap:wrap}
  .meter{position:relative;height:12px;background:#1b1b36;border:1px solid #2a2a52;border-radius:999px;overflow:hidden;min-width:180px}
  .fill{position:absolute;left:0;top:0;bottom:0;width:0;background:linear-gradient(90deg,#ffb454,#ff6b6b)}
  .combo{color:var(--green);font-weight:900}
  .dim{opacity:.7}
  .overlay{position:fixed;inset:0;background:rgba(6,6,14,.75);display:none;align-items:center;justify-content:center;padding:20px;z-index:10}
  .dialog{max-width:520px;width:100%;background:linear-gradient(180deg,#161634,#0e0e22);border:1px solid #2a2a58;border-radius:18px;box-shadow:var(--shadow);padding:22px}
  .dialog h2{margin-top:0}
  .levels{display:grid;grid-template-columns:repeat(auto-fit,minmax(120px,1fr));gap:10px;margin-top:10px}
  .lv{padding:12px 14px;border-radius:12px;background:#1b1b3a;border:1px solid #2a2a58;cursor:pointer;text-align:center;font-weight:800}
  .lv:hover{filter:brightness(1.08)}
  .hidden{display:none !important}
  .hint-line{position:absolute;pointer-events:none;z-index:5;stroke:#7ee8fa;stroke-width:6;stroke-linejoin:round;stroke-linecap:round;filter:drop-shadow(0 0 10px rgba(126,232,250,.6))}
  @media (max-width:600px){.tile{width:52px;height:52px;font-size:28px}}
</style>
</head>
<body>
<div class="container">
  <header>
    <div class="title"><span class="moon">ğŸŒ•</span><span>ä¸‡åœ£èŠ‚è¿è¿çœ‹</span><span class="dim">ï¼ˆæœ€å¤šä¸¤æ¬¡æ‹å¼¯ï¼‰</span></div>
    <div class="panel">
      <span class="badge" id="score">å¾—åˆ† 0</span>
      <span class="badge" id="combo">è¿å‡» x1</span>
      <span class="badge">å…³å¡ <span id="lvLabel">1</span></span>
      <div class="meter"><div class="fill" id="timeFill"></div></div>
      <div class="bar">
        <button class="btn" id="btnHint">æç¤º</button>
        <button class="btn secondary" id="btnShuffle">æ´—ç‰Œ</button>
        <button class="btn ghost" id="btnRestart">é‡å¼€</button>
      </div>
    </div>
  </header>

  <div class="grid-wrap"><div class="grid" id="grid"></div></div>
  <svg id="lines" width="0" height="0" class="hint-svg" style="position:absolute;inset:0;"></svg>
  <footer>ğŸƒ æç¤ºï¼šç‚¹å‡»ä¸¤å¼ ç›¸åŒå›¾æ ‡ï¼Œè‹¥è·¯å¾„ä¸è¶…è¿‡ä¸¤æ¬¡æ‹å¼¯ä¸”ä¸è¢«é˜»æŒ¡å³å¯æ¶ˆé™¤ã€‚</footer>
</div>

<!-- å¼€å§‹ä¸ç»“ç®—å¼¹çª— -->
<div class="overlay" id="startOverlay" style="display:flex;">
  <div class="dialog">
    <h2>ä¸‡åœ£å¤œå¼€å§‹å•¦ ğŸ‘»</h2>
    <p class="dim">é€‰æ‹©å…³å¡å¹¶å¼€å§‹ä½ çš„æ¶ˆé™¤ä¹‹å¤œã€‚æ¯å…³é™æ—¶ï¼Œæ”¯æŒæç¤ºä¸æ´—ç‰Œã€‚</p>
    <div class="levels" id="levels"></div>
  </div>
</div>

<div class="overlay" id="endOverlay">
  <div class="dialog" id="endDialog">
    <h2 id="endTitle">é€šå…³ï¼</h2>
    <p id="endStats" class="dim"></p>
    <div class="bar" style="margin-top:10px">
      <button class="btn" id="btnNext">ä¸‹ä¸€å…³</button>
      <button class="btn ghost" id="btnAgain">å†ç©ä¸€æ¬¡</button>
    </div>
  </div>
</div>

<script>
/** ------- é…ç½® ------- **/
const EMOJIS = ["ğŸƒ","ğŸ‘»","ğŸ¦‡","ğŸ•·ï¸","ğŸ•¸ï¸","ğŸ¬","ğŸ’€","ğŸˆâ€â¬›","ğŸ§™â€â™€ï¸","ğŸ­","ğŸ“š","ğŸ§›"]; // å¯æ›¿æ¢ä¸ºå›¾ç‰‡
const LEVELS = [
  { rows:6, cols:6, kinds:4,  time:30 },
  { rows:7, cols:8, kinds:6,  time:40 },
  { rows:8, cols:10,kinds:8,  time:50 },
  { rows:10,cols:12,kinds:10, time:60 },
];

/** ------- çŠ¶æ€ ------- **/
let state = {
  lv: 0, rows: 0, cols: 0,
  board: [], // å¤–åœˆå¸¦0
  picked: null, score: 0, combo: 1, lastMatchTime: 0,
  timeLeft: 0, timerId: null, lock: false,
};

/** ------- DOM ------- **/
const gridEl = document.getElementById('grid');
const scoreEl = document.getElementById('score');
const comboEl = document.getElementById('combo');
const lvLabel = document.getElementById('lvLabel');
const timeFill = document.getElementById('timeFill');
const startOverlay = document.getElementById('startOverlay');
const endOverlay = document.getElementById('endOverlay');
const endTitle = document.getElementById('endTitle');
const endStats = document.getElementById('endStats');
const btnHint = document.getElementById('btnHint');
const btnShuffle = document.getElementById('btnShuffle');
const btnRestart = document.getElementById('btnRestart');
const btnNext = document.getElementById('btnNext');
const btnAgain = document.getElementById('btnAgain');
const levelsEl = document.getElementById('levels');
const svgLines = document.getElementById('lines');

function randInt(n){ return Math.floor(Math.random()*n); }

/** åˆå§‹åŒ–å…³å¡æŒ‰é’® */
(function initLevels(){
  LEVELS.forEach((lv,i)=>{
    const d=document.createElement('button');
    d.className='lv';
    d.innerHTML=`Lv.${i+1}<br><span class="dim">${lv.rows}Ã—${lv.cols} / ${lv.kinds}ç§ / ${lv.time}s</span>`;
    d.onclick=()=>startGame(i);
    levelsEl.appendChild(d);
  });
})();

/** å¼€å§‹/é‡å¼€/ä¸‹ä¸€å…³ */
function startGame(idx){
  state.lv = idx;
  const cfg = LEVELS[idx];
  state.rows = cfg.rows;
  state.cols = cfg.cols;
  state.score = 0;
  state.combo = 1;
  state.picked = null;
  state.timeLeft = cfg.time;
  updateHud();
  buildBoard(cfg);
  renderBoard();
  startTimer();
  startOverlay.style.display='none';
  endOverlay.style.display='none';
}
btnRestart.onclick = ()=>startGame(state.lv);
btnNext.onclick = ()=> startGame(Math.min(state.lv+1, LEVELS.length-1));
btnAgain.onclick = ()=> startGame(state.lv);

/** æ„å»ºå¸¦å¤–æ¡†çš„æ£‹ç›˜ï¼ˆå››å‘¨åŠ ä¸€åœˆç©ºç™½ä¾¿äºåˆ¤æ–­å¤–éƒ¨è·¯å¾„ï¼‰ */
function buildBoard(cfg){
  const {rows, cols, kinds} = cfg;
  const total = rows * cols;
  const tileCount = total % 2 === 0 ? total : total - 1;
  let pool = [];
  for(let i=0;i<tileCount/2;i++){
    const kind = 1 + randInt(kinds);
    pool.push(kind, kind);
  }
  if(total > tileCount) pool.push(0);

  for(let i=pool.length-1;i>0;i--){ const j=randInt(i+1); [pool[i],pool[j]]=[pool[j],pool[i]]; }

  const inner = [];
  let p=0;
  for(let r=0;r<rows;r++){
    inner[r]=[];
    for(let c=0;c<cols;c++){
      inner[r][c] = pool[p++] ?? 0;
    }
  }

  const R = rows+2, C = cols+2;
  state.board = Array.from({length:R}, (_,r)=>
    Array.from({length:C}, (_,c)=>{
      if(r===0||c===0||r===R-1||c===C-1) return 0;
      return inner[r-1][c-1];
    })
  );

  if(!existsAnyPair()) shuffleUntilSolvable(40);
}

/** æ¸²æŸ“ç½‘æ ¼ */
function renderBoard(){
  gridEl.style.gridTemplateColumns = `repeat(${state.cols}, 1fr)`;
  gridEl.innerHTML='';
  svgLines.innerHTML='';
  svgLines.setAttribute('width', window.innerWidth);
  svgLines.setAttribute('height', window.innerHeight);

  for(let r=1;r<=state.rows;r++){
    for(let c=1;c<=state.cols;c++){
      const v=state.board[r][c];
      const tile=document.createElement('div');
      tile.className='tile'+(v===0?' empty':'');
      tile.dataset.r=r; tile.dataset.c=c;
      if(v>0){ tile.textContent = EMOJIS[v-1]; }
      tile.onclick=()=>onPick(r,c,tile);
      gridEl.appendChild(tile);
    }
  }
  lvLabel.textContent = (state.lv+1);
}

/** è®¡æ—¶å™¨ */
function startTimer(){
  clearInterval(state.timerId);
  const total = LEVELS[state.lv].time;
  state.timeLeft = total;
  timeFill.style.width='0%';
  state.timerId = setInterval(()=>{
    state.timeLeft -= 1;
    timeFill.style.width = `${(state.timeLeft/total)*100}%`;
    if(state.timeLeft<=0){
      clearInterval(state.timerId);
      showEnd(false);
    }
  },1000);
}

/** HUD */
function updateHud(){
  scoreEl.textContent = `å¾—åˆ† ${state.score}`;
  comboEl.textContent = `è¿å‡» x${state.combo}`;
}

/** ç‚¹å‡»å¤„ç† */
function onPick(r,c,el){
  const v = state.board[r][c];
  if(state.lock || v===0) return;

  if(!state.picked){
    state.picked = {r,c,el,v};
    el.classList.add('selected');
    return;
  }
  if(state.picked.r===r && state.picked.c===c) return;

  if(state.picked.v !== v){
    state.picked.el.classList.remove('selected');
    state.picked = {r,c,el,v};
    el.classList.add('selected');
    return;
  }

  const a = {r:state.picked.r, c:state.picked.c};
  const b = {r, c};
  const path = canConnect(a,b);
  if(path){
    state.lock = true;
    drawPath(path);
    state.picked.el.classList.remove('selected');
    state.picked.el.classList.add('clearing');
    el.classList.add('clearing');

    setTimeout(()=>{
      state.board[a.r][a.c]=0;
      state.board[b.r][b.c]=0;
      state.picked.el.className='tile empty'; state.picked.el.textContent='';
      el.className='tile empty'; el.textContent='';
      clearPath();
      state.lock=false;
      state.picked=null;

      const now = performance.now();
      state.combo = (now - state.lastMatchTime < 1800) ? Math.min(state.combo+1, 10) : 1;
      state.lastMatchTime = now;
      state.score += 10 * state.combo;
      updateHud();

      if(isCleared()){
        showEnd(true);
      }else if(!existsAnyPair()){
        shuffleUntilSolvable(40,true);
      }
    },260);
  }else{
    state.picked.el.classList.remove('selected');
    state.picked = {r,c,el,v};
    el.classList.add('selected');
  }
}

/** ------- è·¯å¾„åˆ¤å®šï¼ˆä¿®æ­£ç‰ˆï¼‰ ------- */
/** ç›´çº¿æ˜¯å¦æ— é˜»æŒ¡ï¼ˆä¸å«ä¸¤ç«¯ï¼‰ */
function clearLine(a, b){
  if (a.r === b.r) {
    const r = a.r, c1 = Math.min(a.c, b.c), c2 = Math.max(a.c, b.c);
    for (let c = c1 + 1; c < c2; c++) if (state.board[r][c] !== 0) return false;
    return true;
  }
  if (a.c === b.c) {
    const c = a.c, r1 = Math.min(a.r, b.r), r2 = Math.max(a.r, b.r);
    for (let r = r1 + 1; r < r2; r++) if (state.board[r][c] !== 0) return false;
    return true;
  }
  return false;
}

/** 0/1/2 æ‹åˆ¤å®šï¼ˆå«å¤–åœˆè·¯å¾„ï¼‰ */
function canConnect(a, b){
  if (a.r === b.r && a.c === b.c) return null;

  // 0 æ‹
  if ((a.r === b.r || a.c === b.c) && clearLine(a, b)) return [a, b];

  // 1 æ‹
  const p1 = { r: a.r, c: b.c };
  if (state.board[p1.r][p1.c] === 0 && clearLine(a, p1) && clearLine(p1, b)) return [a, p1, b];

  const p2 = { r: b.r, c: a.c };
  if (state.board[p2.r][p2.c] === 0 && clearLine(a, p2) && clearLine(p2, b)) return [a, p2, b];

  // 2 æ‹ï¼šç©·ä¸¾æ‰€æœ‰è¡Œ/åˆ—ï¼Œæ‰¾ä¸¤ä¸ªæ‹ç‚¹å‡ä¸ºç©ºï¼Œä¸”ä¸‰æ®µç›´çº¿å‡é€š
  const R = state.board.length, C = state.board[0].length;

  for (let r = 0; r < R; r++) {
    if (state.board[r][a.c] !== 0 || state.board[r][b.c] !== 0) continue;
    const pA = { r, c: a.c }, pB = { r, c: b.c };
    if (clearLine(a, pA) && clearLine(pA, pB) && clearLine(pB, b)) return [a, pA, pB, b];
  }
  for (let c = 0; c < C; c++) {
    if (state.board[a.r][c] !== 0 || state.board[b.r][c] !== 0) continue;
    const pA = { r: a.r, c }, pB = { r: b.r, c };
    if (clearLine(a, pA) && clearLine(pA, pB) && clearLine(pB, b)) return [a, pA, pB, b];
  }
  return null;
}

/** æ˜¯å¦å·²æ¸…ç©ºï¼ˆé™¤å¤–æ¡†ï¼‰ */
function isCleared(){
  for(let r=1;r<=state.rows;r++)
    for(let c=1;c<=state.cols;c++)
      if(state.board[r][c]!==0) return false;
  return true;
}

/** æ˜¯å¦å­˜åœ¨ä»»æ„å¯è¿çš„ä¸€å¯¹ï¼ˆç”¨äºæ­»å±€æ£€æµ‹/æç¤ºï¼‰ */
function existsAnyPair(){
  const groups = new Map();
  for(let r=1;r<=state.rows;r++)
    for(let c=1;c<=state.cols;c++){
      const v = state.board[r][c];
      if(v>0){ if(!groups.has(v)) groups.set(v,[]); groups.get(v).push({r,c,v}); }
    }
  for(const list of groups.values()){
    for(let i=0;i<list.length;i++){
      for(let j=i+1;j<list.length;j++){
        if(canConnect(list[i], list[j])) return true;
      }
    }
  }
  return false;
}

/** æ´—ç‰Œï¼ˆä¿æŒéç©ºæ ¼æ‰“æ•£ï¼‰ */
function shuffleBoard(){
  const cells=[];
  for(let r=1;r<=state.rows;r++)
    for(let c=1;c<=state.cols;c++)
      if(state.board[r][c]>0) cells.push(state.board[r][c]);
  for(let i=cells.length-1;i>0;i--){ const j=randInt(i+1); [cells[i],cells[j]]=[cells[j],cells[i]]; }
  let k=0;
  for(let r=1;r<=state.rows;r++)
    for(let c=1;c<=state.cols;c++)
      if(state.board[r][c]>0) state.board[r][c]=cells[k++];

  // æ›´æ–°DOM
  let idx=0;
  [...gridEl.children].forEach((el)=>{
    const r = 1 + Math.floor(idx/state.cols);
    const c = 1 + (idx%state.cols);
    idx++;
    const v = state.board[r][c];
    if(v>0){ el.className='tile'; el.textContent=EMOJIS[v-1]; }
    else { el.className='tile empty'; el.textContent=''; }
  });
}

/** å¤šæ¬¡æ´—ç‰Œç›´è‡³å¯è§£ */
function shuffleUntilSolvable(limit=30, showTip=false){
  for(let i=0;i<limit;i++){
    if(existsAnyPair()){ if(showTip) toast('æ— è§£ï¼Ÿå·²è‡ªåŠ¨æ´—ç‰Œ'); return; }
    shuffleBoard();
  }
}

/** ç”»æç¤ºçº¿ */
function drawPath(points){
  clearPath();
  const rect = gridEl.getBoundingClientRect();
  const gap = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--grid-gap')) || 8;
  const sample = gridEl.querySelector('.tile');
  const w = sample ? sample.getBoundingClientRect().width : 64;
  const h = sample ? sample.getBoundingClientRect().height : 64;

  const toXY = (p)=>{
    const x = rect.left + (p.c-1)*(w+gap) + w/2 + gap;
    const y = rect.top  + (p.r-1)*(h+gap) + h/2 + gap;
    return {x,y};
  };
  const path = points.map(toXY);

  const poly = document.createElementNS('http://www.w3.org/2000/svg','polyline');
  poly.setAttribute('points', path.map(p=>`${p.x},${p.y}`).join(' '));
  poly.classList.add('hint-line');
  svgLines.appendChild(poly);
}
function clearPath(){ svgLines.innerHTML=''; }

/** æç¤ºï¼šæ‰¾ä¸€å¯¹å¯è¿å¹¶é—ªçº¿ */
function hint(){
  const groups = new Map();
  for(let r=1;r<=state.rows;r++)
    for(let c=1;c<=state.cols;c++){
      const v=state.board[r][c];
      if(v>0){ if(!groups.has(v)) groups.set(v,[]); groups.get(v).push({r,c,v}); }
    }
  for(const list of groups.values()){
    for(let i=0;i<list.length;i++){
      for(let j=i+1;j<list.length;j++){
        const path = canConnect(list[i], list[j]);
        if(path){
          drawPath(path);
          setTimeout(clearPath, 900);
          return;
        }
      }
    }
  }
  toast('å½“å‰æ— è§£ï¼Œå»ºè®®æ´—ç‰Œ');
}

/** ç®€æ˜“åå¸ */
let toastTimer=null;
function toast(msg){
  clearTimeout(toastTimer);
  let el = document.getElementById('toast');
  if(!el){
    el = document.createElement('div');
    el.id='toast';
    el.style.position='fixed';
    el.style.left='50%'; el.style.top='14px'; el.style.transform='translateX(-50%)';
    el.style.padding='10px 14px'; el.style.borderRadius='12px';
    el.style.background='rgba(20,20,50,.9)'; el.style.border='1px solid #2a2a58';
    el.style.color='#fff'; el.style.fontWeight='700'; el.style.boxShadow='var(--shadow)';
    el.style.zIndex='20';
    document.body.appendChild(el);
  }
  el.textContent=msg;
  el.style.display='block';
  toastTimer=setTimeout(()=>{ el.style.display='none'; }, 1200);
}

/** ç»“æŸå¼¹çª— */
function showEnd(win){
  endTitle.textContent = win ? 'é€šå…³ï¼ğŸ‰' : 'æ—¶é—´åˆ°ï¼';
  endStats.textContent = `å¾—åˆ†ï¼š${state.score}ï½œè¿å‡»ï¼šx${state.combo}`;
  endOverlay.style.display='flex';
  clearInterval(state.timerId);
}

/** äº‹ä»¶ç»‘å®š */
btnHint.onclick = ()=>hint();
btnShuffle.onclick = ()=>{
  shuffleBoard();
  if(!existsAnyPair()) shuffleUntilSolvable(60,true);
};
btnRestart.onclick = ()=>startGame(state.lv);

/** å¯åŠ¨ */
window.addEventListener('load', ()=>{
  updateHud();
});
</script>
</body>
</html>
